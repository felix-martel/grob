{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Group files together in a flexible way using glob-like patterns.</p> <pre><code>pip install grob\n</code></pre> <p>In its simplest form, <code>grob</code> simply lists all files in a directory:</p> <pre><code>~ grob \"*\" .\n[\n  \"examples/one_tag_same_dir/root/image_001.png\",\n  \"examples/one_tag_same_dir/root/image_002.jpg\",\n  \"examples/one_tag_same_dir/root/image_003.gif\"\n]\n</code></pre> <p>given the following directory content:</p> <pre><code>root\n\u251c\u2500\u2500 image_001.png\n\u251c\u2500\u2500 image_002.jpg\n\u2514\u2500\u2500 image_003.gif\n</code></pre> <p>However, <code>grob</code> is mainly useful to group different files together. Let's say you have images and corresponding JSON description for each image:</p> <pre><code>root\n\u251c\u2500\u2500 image_1.png\n\u251c\u2500\u2500 image_2.png\n\u251c\u2500\u2500 image_3.png\n\u251c\u2500\u2500 labels_1.json\n\u251c\u2500\u2500 labels_2.json\n\u2514\u2500\u2500 labels_3.json\n</code></pre> <pre><code>~ grob \"image=image_{id}.png,labels=labels_{id}.json\" .\n{\n    \"1\": {\"image\": \"image_1.png\", \"labels\": \"labels_1.json\"},\n    \"2\": {\"image\": \"image_2.png\", \"labels\": \"labels_2.json\"},\n    \"3\": {\"image\": \"image_3.png\", \"labels\": \"labels_3.json\"}\n}\n</code></pre> <p>Now imagine each group of inputs is stored in the same subdirectory:</p> <pre><code>root\n\u251c\u2500\u2500 group_a\n\u2502   \u251c\u2500\u2500 image.png\n\u2502   \u2514\u2500\u2500 labels.json\n\u251c\u2500\u2500 group_b\n\u2502   \u251c\u2500\u2500 image.png\n\u2502   \u2514\u2500\u2500 labels.json\n\u251c\u2500\u2500 group_c\n\u2502   \u251c\u2500\u2500 image.png\n\u2502   \u2514\u2500\u2500 labels.json\n\u2514\u2500\u2500 group_d\n    \u251c\u2500\u2500 image.png\n    \u2514\u2500\u2500 labels.json\n</code></pre> <p>We just need to update our pattern:</p> <pre><code>~ grob \"image=group_{name}/*.png,labels=group_{name}/*.json\" .\n{\n    \"a\": {\"image\": \"group_a/image.png\", \"labels\": \"group_a/labels.json\"},\n    \"b\": {\"image\": \"group_b/image.png\", \"labels\": \"group_b/labels.json\"},\n    \"c\": {\"image\": \"group_c/image.png\", \"labels\": \"group_c/labels.json\"},\n    \"d\": {\"image\": \"group_d/image.png\", \"labels\": \"group_d/labels.json\"}\n}\n</code></pre> <p>What if each type of file lives in its own directory?</p> <pre><code>root\n\u251c\u2500\u2500 images\n\u2502   \u251c\u2500\u2500 fifi.gif\n\u2502   \u251c\u2500\u2500 loulou.png\n\u2502   \u2514\u2500\u2500 riri.jpg\n\u2514\u2500\u2500 labels\n    \u251c\u2500\u2500 fifi.json\n    \u251c\u2500\u2500 loulou.json\n    \u2514\u2500\u2500 riri.json\n</code></pre> <pre><code>~ grob \"image=images/{name}.*,labels={name}.json\" .\n{\n    \"riri\": {\"image\": \"images/riri.jpg\", \"labels\": \"labels/riri.json\"},\n    \"fifi\": {\"image\": \"images/fifi.gif\", \"labels\": \"labels/fifi.json\"},\n    \"loulou\": {\"image\": \"images/loulou.png\", \"labels\": \"labels/loulou.json\"}\n}\n</code></pre> <p>See more in the <code>examples/</code> diretory, or check <code>tests/examples/</code> for end-to-end tests showing <code>grob</code> in action.</p>"},{"location":"cli/","title":"CLI Reference","text":"<pre><code>usage: grob [--multiple [TAG [TAG ...]]] [--optional [TAG [TAG ...]]]\n            [--remove-on-missing [TAG [TAG ...]]]\n            [--fail-on-missing [TAG [TAG ...]]] [--key PATTERN]\n            [--output OUTPUT]\n            [--output-format {json,jsonl,human,csv,tsv} | --json | --jsonl | --human | --csv | --tsv]\n            [--no-squeeze] [--no-list] [--relative | --absolute]\n            [--with-keys | --without-keys] [--help]\n            PATTERN [ROOT_DIR]\n</code></pre> <p>Group different files together by extracting keys from their names and matching those keys together. The simplest <code>PATTERN</code> is <code>*</code>, which will match all files in <code>ROOT_DIR</code>. In that case, each \"group\" of files will comprise a single file. A more useful <code>PATTERN</code> is <code>a=A/{name}.*,b=B/{name}.*</code>, which will match files from different directories A and B based on their stems. The output could look like this:</p> <pre><code>{\n    \"file_1\": {\"a\": \"A/file_1.txt\", \"b\": \"B/file_1.log\"},\n    \"file_2\": {\"a\": \"A/file_2.txt\", \"b\": \"B/file_2.log\"},\n    ...\n}\n</code></pre> <p>Here, <code>file_1</code> and <code>file_2</code> are the keys, while <code>a</code> and <code>b</code> are the tags. More generally, <code>PATTERN</code> is a comma-separated list of <code>&lt;tag&gt;=&lt;pattern&gt;</code> pairs, where <code>&lt;tag&gt;</code> is the name of the tag (e.g. <code>a</code> or <code>b</code>) and <code>&lt;pattern&gt;</code> describes where to find the files and how to extract a key from their paths.</p> <pre><code>positional arguments:\n  PATTERN               Pattern describing which tags are present and how to\n                        extract their keys.\n  ROOT_DIR              Root directory where files are located.\n\noptional arguments:\n  --multiple [TAG [TAG ...]]\n                        List of tags that accept multiple files. By default,\n                        tags expect a single matching file for any given key.\n                        When `--multiple` is passed, the tag will contain a\n                        list of paths, instead of a single path.\n  --optional [TAG [TAG ...]]\n                        List of optional tags. If a group doesn't have one of\n                        these tags, the tag will be present with null value.\n                        By default, all tags are mandatory.\n  --remove-on-missing [TAG [TAG ...]]\n                        List of strictly mandatory tags. If a group doesn't\n                        have one of these tags, it will be removed from the\n                        output.\n  --fail-on-missing [TAG [TAG ...]]\n                        List of mandatory tags. If a group doesn't have one of\n                        these tags, grob will fail with exit code 1. This is\n                        the default for all tags.\n  --key PATTERN         Provide a custom pattern to build the group keys. It\n                        can (and should) use any of the placeholders contained\n                        in PATTERN: for example, if PATTERN is\n                        '**/{parent}/{name}.{ext}', --key could be\n                        '{parent}-{name}-{ext}'.\n  --output OUTPUT, -o OUTPUT\n                        Where to write the output. Default to stdout.\n  --help                Show this help message and exit\n\nOutput format:\n  Controls how the output is formatted.\n\n  --output-format {json,jsonl,human,csv,tsv}, -f {json,jsonl,human,csv,tsv}\n                        Specify the output format. Default to 'json'.\n  --json, -j            Output a JSON string.\n  --jsonl, -l           Output a JSON Line string, i.e. each line is a valid\n                        JSON record.\n  --human, -h           Output a human readable table.\n  --csv                 Output a CSV file, with one group per line and one tag\n                        per column. This format isn't recommended when using\n                        --multiple.\n  --tsv                 Output a TSV file, with one group per line and one tag\n                        per column. This format isn't recommended when using\n                        --multiple.\n  --no-squeeze          Never squeeze file groups, even if no named tag were\n                        provided. By default, when all groups only contain one\n                        file and no named tag were provided, the output is\n                        squeezed into a list of paths.\n  --no-list             Always return a dictionary, even if no key was\n                        provided. By default, if no named placeholder is used,\n                        assume the user isn't interested in the key, but only\n                        in the group themselves.\n  --relative            Output paths relative to ROOT_DIR.\n  --absolute            Output absolute paths.\n  --with-keys, -k       Return group keys alongside the group themselves. This\n                        is the default.\n  --without-keys, -K    Return only the file groups, not their keys.\n</code></pre>"},{"location":"modules/","title":"API Reference","text":"<p>Find and group files together using glob-like patterns.</p> <p>A single pattern will create a tag with a default name: <pre><code>\"data/image_{index}.png\"\n</code></pre> will create groups <code>{\"001\": {\"default\": \"data/image_001.png\"}, \"002\": {\"default\": \"data/image_002.png\"}...}</code>.</p> <p>A dictionary will create one tag for each key in the dictionary. The values of the dictionary can be either a pattern, or a dictionary specifying tag-specific options, e.g.: <pre><code>{\n    \"image\": \"data/{year}/image_{index}.png\",\n    \"legend\": {\n        \"spec\": \"legends/legend_*_{year}_{index}.txt,\n        \"allow_multiple\": True,\n        \"on_missing\": \"ignore\",\n    }\n}\n</code></pre> will create two tags <code>image</code> and <code>legend</code>, the latter being optional and accepting multiple files.</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>Union[TagSpec, Dict[str, TagSpec]]</code> <p>describes how to find and group files. It can be a single pattern (in which case a tag with a default name will be created) or a mapping from tag names to patterns. For tag-specific options (i.e. indicate what to do if a tag is missing from a group), a mapping from tag names to tag options can be provided</p> required <code>root_dir</code> <code>Union[str, Path]</code> <p>where to look for files. <code>root_dir</code> will be walked recursively</p> required <code>key_formatter</code> <code>Union[str, Callable[[MultiPartKey], GroupKey], None]</code> <p>specify how to format keys. By default, all key parts (such as <code>year</code> or <code>index</code> in the example above) are concatenated with underscores. <code>key_formatter</code> can be either a f-string or a function that takes a dictionary of parts (e.g. <code>{\"year\": 2020, \"index\": 1}</code>) and returns a string</p> <code>None</code> <code>use_relative_paths</code> <code>bool</code> <p>if True, return paths relative to <code>root_dir</code>. Otherwise, return absolute paths</p> <code>False</code> <code>squeeze</code> <code>bool</code> <p>if True, the output will be squeezed when possible (i.e. tag will be omitted from the output if it is not ambiguous)</p> <code>True</code> <code>with_keys</code> <code>Optional[bool]</code> <p>whether to include the group keys in the output</p> <code>None</code> <code>compress_to_list</code> <code>bool</code> <p>if True, the value of <code>with_keys</code> will be automatically set from <code>patterns</code>. Ignored if <code>with_keys</code> is passed</p> <code>True</code> <p>Returns:</p> Type Description <code>FormattedGroups</code> <p>files matching <code>patterns</code>, grouped by common keys and tags</p> Source code in <code>grob/core/finder.py</code> <pre><code>def find(\n    patterns: Union[TagSpec, Dict[str, TagSpec]],\n    root_dir: Union[str, Path],\n    key_formatter: Union[str, Callable[[MultiPartKey], GroupKey], None] = None,\n    use_relative_paths: bool = False,\n    squeeze: bool = True,\n    with_keys: Optional[bool] = None,\n    compress_to_list: bool = True,\n) -&gt; FormattedGroups:\n    \"\"\"Find and group files together using glob-like patterns.\n\n    A single pattern will create a tag with a default name:\n    ```\n    \"data/image_{index}.png\"\n    ```\n    will create groups `{\"001\": {\"default\": \"data/image_001.png\"}, \"002\": {\"default\": \"data/image_002.png\"}...}`.\n\n    A dictionary will create one tag for each key in the dictionary. The values of the dictionary can be either a\n    pattern, or a dictionary specifying tag-specific options, e.g.:\n    ```\n    {\n        \"image\": \"data/{year}/image_{index}.png\",\n        \"legend\": {\n            \"spec\": \"legends/legend_*_{year}_{index}.txt,\n            \"allow_multiple\": True,\n            \"on_missing\": \"ignore\",\n        }\n    }\n    ```\n    will create two tags `image` and `legend`, the latter being optional and accepting multiple files.\n\n    Args:\n        patterns: describes how to find and group files. It can be a single pattern (in which case a tag with a default\n            name will be created) or a mapping from tag names to patterns. For tag-specific options (i.e. indicate what\n            to do if a tag is missing from a group), a mapping from tag names to tag options can be provided\n        root_dir: where to look for files. `root_dir` will be walked recursively\n        key_formatter: specify how to format keys. By default, all key parts (such as `year` or `index` in the example\n            above) are concatenated with underscores. `key_formatter` can be either a f-string or a function that takes\n            a dictionary of parts (e.g. `{\"year\": 2020, \"index\": 1}`) and returns a string\n        use_relative_paths: if True, return paths relative to `root_dir`. Otherwise, return absolute paths\n        squeeze: if True, the output will be squeezed when possible (i.e. tag will be omitted from the output if it is\n            not ambiguous)\n        with_keys: whether to include the group keys in the output\n        compress_to_list: if True, the value of `with_keys` will be automatically set from `patterns`. Ignored if\n            `with_keys` is passed\n\n    Returns:\n        files matching `patterns`, grouped by common keys and tags\n    \"\"\"\n    root_dir = Path(root_dir)\n    root_dir = root_dir.resolve()\n    tags = create_tags(patterns)\n    with_keys = _update_with_keys(with_keys, allow_auto_keys=compress_to_list, tags=tags)\n    key_formatter = get_key_formatter(key_formatter, tags=tags)\n    files = walk(root_dir)\n    files_by_tag = find_by_tag(files, tags)\n    groups = group_by_key(files_by_tag, key_formatter=key_formatter)\n    groups = filter_and_validate_groups(groups, tags=tags)\n    return format_groups(\n        groups,\n        tag_names=[tag.name for tag in tags],\n        relative_to=root_dir if use_relative_paths else None,\n        squeeze=squeeze,\n        with_keys=with_keys,\n    )\n</code></pre> <p>options: show_root_toc_entry: true show_root_heading: true show_signature: false show_source: false</p>"},{"location":"user_guide/","title":"User Guide","text":"<p><code>grob</code> creates groups of files that belong together. Each group has a unique key ; within a group, files can be organized into tags.</p> <p>Let's take for example the Rider Safety &amp; Compliance dataset on Kaggle: for a given subset, it contains pairs of images and labels:</p> <pre><code>\u251c\u2500\u2500 images\n\u2502   \u251c\u2500\u2500 new1.jpg\n\u2502   \u251c\u2500\u2500 new2.jpg\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 labels\n    \u251c\u2500\u2500 new1.txt\n    \u251c\u2500\u2500 new2.txt\n    \u2514\u2500\u2500 ...\n</code></pre> <p>To use it, we need to join images with their corresponding label files:</p> <pre><code>{\n  \"1\": {\"image\":  \"images/new1.jpg\", \"labels\":  \"labels/new1.jpg\"},\n  \"2\": {\"image\":  \"images/new2.jpg\", \"labels\":  \"labels/new2.jpg\"},\n  ...\n}\n</code></pre> <p>Each group has a unique key: <code>1</code>, <code>2</code> and so on. Within a group, files are organized into tags: <code>image</code> and <code>labels</code> in the above example.</p>"},{"location":"user_guide/#basics","title":"Basics","text":"<p>Let's start by getting the image files:</p> <pre><code>~ grob \"images/new*.jpg\" train\n[\n  \"images/new1.jpg\",\n  \"images/new2.jpg\",\n   ...\n]\n</code></pre> <p>We specified a glob pattern <code>images/*.jpg</code>, and <code>grob</code> returned all matching files. Now we can specify which part of the path we want to use as key, by declaring a placeholder with braces:</p> <pre><code>~ grob \"images/new{id}.jpg\" train\n{\n  \"1\": \"images/new1.jpg\",\n  \"2\": \"images/new2.jpg\",\n  ...\n}\n</code></pre> <p><code>images/new{id}.jpg</code> will match the same files as <code>images/new*.jpg</code>, but it will tell <code>grob</code> to extract the matched value and use it as the <code>id</code> part of the key. We can now declare how to find the labels:</p> <pre><code>~ grob \"image=images/new{id}.jpg, labels=labels/new{id}.txt\" train\n{\n  \"1\": {\n    \"image\": \"images/new1.jpg\",\n    \"labels\": \"labels/new1.txt\"\n  },\n  \"2\": {\n    \"image\": \"images/new2.jpg\",\n    \"labels\": \"labels/new2.txt\"\n  },\n  ...\n}\n</code></pre> <p>For each tag <code>image</code> and <code>labels</code>, <code>grob</code> will find the files matching the pattern, extract any named placeholder and join them into a single key. It will then match together files that have the same key.</p>"},{"location":"user_guide/#working-with-incomplete-groups","title":"Working with incomplete groups","text":"<p>In practice, the command above would fail if one of the groups is missing any of the tags. You can change this behavior by passing:</p> <ul> <li><code>--optional</code> will make all tags optional. The tag will contain <code>null</code> instead of an actual file.</li> <li><code>--remove-on-missing</code> will remove all incomplete groups from the final outputs.</li> </ul> <p>These two options accept a list of tags: for example, using <code>--optional labels --remove-on-missing image</code> would keep images without labels but remove labels without images.</p>"},{"location":"user_guide/#more-complex-keys","title":"More complex keys","text":"<p>You're not limited to a single placeholder per pattern. Our example dataset has two subsets, <code>train</code> and <code>val</code>. We want to get files from both subset, but we don't want to group an image from the training set with a label from the validation set. We can use:</p> <pre><code>~ grob \"image={subset}/images/new{id}.jpg, labels={subset}/labels/new{id}.txt\" .\n{\n  \"train_1\": {\n    \"image\": \"train/images/new1.jpg\",\n    \"labels\": \"train/labels/new1.txt\"\n  },\n  ...\n  \"val_1\": {\n    \"image\": \"val/images/new1.jpg\",\n    \"labels\": \"val/labels/new1.txt\"\n  }\n}\n</code></pre> <p>Here, placeholders <code>{subset}</code> and <code>{id}</code> are concatenated to build the final key. A custom formatter can be passed with the <code>--key</code> option, using standard Python f-strings:</p> <pre><code>~ grob \"image={subset}/images/new{id}.jpg, labels={subset}/labels/new{id}.txt\" . --key \"{subset}-{id:0&gt;3}\"\n{\n  \"train-001\": {\n    \"image\": \"train/images/new1.jpg\",\n    \"labels\": \"train/labels/new1.txt\"\n  },\n  \"train-002\": {\n    \"image\": \"train/images/new2.jpg\",\n    \"labels\": \"train/labels/new2.txt\"\n  },\n}\n</code></pre> <p>If you're not interested in the keys, but only in the files themselves, you can use <code>--without-keys</code> or <code>-K</code>:</p> <pre><code>~ grob \"image={subset}/images/new{id}.jpg, labels={subset}/labels/new{id}.txt\" . --without-keys\n[\n  {\n    \"image\": \"train/images/new1.jpg\",\n    \"labels\": \"train/labels/new1.txt\"\n  },\n  ...\n]\n</code></pre>"},{"location":"user_guide/#more-complex-patterns","title":"More complex patterns","text":"<p>Patterns also support:</p> <ul> <li><code>**</code> for matching zero or more directories</li> <li>option groups <code>(a|b|c)</code> to match several options. Typically, use <code>*.(jpg|png|gif)</code> to match any of these extensions. Option groups cannot contain wildcards or placeholders.</li> <li>placeholder flags to restrict what a placeholder can match</li> </ul> <p>For complete control, a regular expression can be passed instead of a glob-like pattern.</p>"},{"location":"user_guide/#placeholder-flags","title":"Placeholder flags","text":"<p>As explained above, a placeholder will match the same as <code>*</code> (i.e. any character but a slash). We can add placeholder flags to restrict which characters can be matched by a placeholder:</p> <ul> <li><code>d</code> will only match digits</li> <li><code>a</code> will only match alphanumeric characters</li> <li><code>&gt;3</code> will match three characters or more</li> <li><code>&lt;3</code> will match three characters or fewer</li> <li><code>3</code> will match exactly three characters</li> <li><code>3-9</code> will match three to nine characters</li> </ul> <p>Placeholder flags must be indicated within the placeholder, after a colon <code>:</code>, e.g. <code>{name:a&gt;3}</code>. Multiple flags can be combined.</p>"},{"location":"user_guide/#regular-expressions","title":"Regular expressions","text":"<p>For even more control, one can use regular expressions instead of glob-like patterns. Regular expressions must use the regular Python syntax. Placeholders must be indicated with named capturing groups <code>(?P&lt;placeholder_name&gt;...)</code>. To indicate that a pattern must be intepreted as a regular expression, it must end with a <code>:r</code> flag.</p> <p>For example, this will only match images whose id contains a three:</p> <pre><code>~ grob \"image=images/new(?P&lt;id&gt;\\d*3|3\\d*)[.]jpg:r, labels=labels/new{id}.txt:r\" . --remove-on-missing\n</code></pre>"},{"location":"user_guide/#multiple-files-per-tag","title":"Multiple files per tag","text":"<p>By default, <code>grob</code> expects exactly one file per group and per tag, and will fail if multiple files match a given pattern for a group. This behavior can be turned off with the <code>--multiple</code>:</p> <ul> <li><code>--multiple TAG1 TAG2 ...</code> will make <code>TAG1</code> and <code>TAG2</code> contain a list of files</li> <li><code>--multiple</code> will make all tags contain a list of files</li> </ul>"},{"location":"user_guide/#distribute-file-over-groups","title":"Distribute file over groups","text":"<p>Sometimes, you'll want the same file to be included in multiple groups. For example, let's say we have tracks and covers from different albums:</p> <pre><code>\u251c\u2500\u2500 Miles Ahead\n\u2502   \u251c\u2500\u2500 cover.jpg\n\u2502   \u251c\u2500\u2500 01 - Springsville.mp3\n\u2502   \u251c\u2500\u2500 02 - The Maids of Cadiz.mp3\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 Kind of Blue\n    \u251c\u2500\u2500 cover.jpg\n    \u251c\u2500\u2500 01 - So What.mp3\n    \u251c\u2500\u2500 02 - Freddie Freeloader.mp3\n    \u2514\u2500\u2500 ...\n</code></pre> <p>Each cover must be associated to all tracks from the album. Tags can be described as usual:</p> <pre><code>~ grob \"track={album}/{track:d2}*.mp3, cover={album}/cover.jpg\" .\n</code></pre> <p><code>grob</code> will detect that tag <code>cover</code> is missing the <code>{track}</code> placeholder, and will automatically distribute covers over the common placeholders, achieving the desired behavior.</p> Deep Dive <p>To better understand what's going on in this case, consider the files after the search step and before the join step.</p> <p>For tag <code>track</code>:</p> <code>{album}</code> <code>{track}</code> File Miles Ahead 01 `Miles Ahead/01 - Springsville.mp3 Miles Ahead 02 `Miles Ahead/01 - Springsville.mp3 ... ... ... <p>For tag <code>cover</code>:</p> <code>{album}</code> File Miles Ahead <code>Miles Ahead/cover.jpg</code> Kind of Blue <code>Kind of Blue/cover.jpg</code> <p><code>grob</code> will perform an outer join over the common keys, in that case <code>{album}</code>, thus giving the following result:</p> <code>{album}</code> <code>{track}</code> <code>track</code> <code>cover</code> Miles Ahead 01 <code>Miles Ahead/01 - Springsville.mp3</code> <code>Miles Ahead/cover.jpg</code> Miles Ahead 02 <code>Miles Ahead/01 - Springsville.mp3</code> <code>Miles Ahead/cover.jpg</code> ... ... ... ..."},{"location":"user_guide/#output-format","title":"Output format","text":"<p><code>grob</code> supports the following formats, controlled by the <code>--output-format, -f</code> option:</p> Format Description Shortcut <code>json</code> JSON mapping from keys to groups <code>--json, -j</code> <code>jsonl</code> one JSON record per group <code>--jsonl, -l</code> <code>human</code> human readable table (not implemented yet) <code>--human, -h</code> <code>csv</code> comma-separated file, with one tag per column <code>--csv</code> <code>tsv</code> tab-separated file, same format <code>--tsv</code> <p><code>--output, -o</code> allows you to choose where to write the output (default to <code>stdout</code>).</p> <p><code>--absolute</code> will return absolute file paths, instead of paths relative to the root directory.</p>"}]}